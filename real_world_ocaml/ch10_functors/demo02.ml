open Core

(* Letâ€™s consider a more realistic example of how to use functors: a library for computing with intervals. *)
module type Comparable = sig
  type t

  val compare : t -> t -> int
end

module type Interval_intf = sig
  type t
  type endpoint

  val create : endpoint -> endpoint -> t
  val is_empty : t -> bool
  val contains : t -> endpoint -> bool
  val intersect : t -> t -> t
end

(* The functor for creating the interval module follows *)
module Make_interval (Endpoint : Comparable) : Interval_intf = struct
  type endpoint = Endpoint.t
  type t = Interval of Endpoint.t * Endpoint.t | Empty

  (** [create low high] creates a new interval from [low] to [high]. If [low > high], then the
      interval is empty *)
  let create low high = if Endpoint.compare low high > 0 then Empty else Interval (low, high)

  (** Returns true iff the interval is empty *)
  let is_empty = function Empty -> true | _ -> false

  (** [contains t x] returns true iff [x] is contained in the interval [t] *)
  let contains t x =
    match t with
    | Empty -> false
    | Interval (low, high) -> Endpoint.compare x low >= 0 && Endpoint.compare x high <= 0

  (** [intersect t1 t2] returns the intersection of the two input intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y <= 0 then x else y in
    let max x y = if Endpoint.compare x y >= 0 then x else y in
    match (t1, t2) with
    | Empty, _ | _, Empty -> Empty
    | Interval (l1, h1), Interval (l2, h2) -> create (max l1 l2) (min h1 h2)
end

module Int_interval = Make_interval (Int)

(* The constant 3 has type int but an expression was expected of type
  Int_interval.endpoint *)
(* let _ = Int_interval.create 3 4 *)

(* Need to expose the fact that endpoint is equal to Int.t (or more generally, Endpoint.t, where Endpoint is the argument to the functor). *)

(* option 01: use a sharing constraint to create a specialized version of Interval_intf for integer intervals *)
module type Int_interval_intf = Interval_intf with type endpoint = int

(* option 01: use sharing constraints in the context of a functor:
expose that some of the types of the module being generated by the functor are related to the types in the module fed to the functor.
*)

(* example: expose an equality between the type endpoint in the new module and the type Endpoint.t, from the module Endpoint that is the functor argument. *)
module Make_interval_v2 (Endpoint : Comparable) : Interval_intf with type endpoint = Endpoint.t =
struct
  type endpoint = Endpoint.t
  type t = Interval of Endpoint.t * Endpoint.t | Empty

  (** [create low high] creates a new interval from [low] to [high]. If [low > high], then the
      interval is empty *)
  let create low high = if Endpoint.compare low high > 0 then Empty else Interval (low, high)

  (** Returns true iff the interval is empty *)
  let is_empty = function Empty -> true | Interval _ -> false

  (** [contains t x] returns true iff [x] is contained in the interval [t] *)
  let contains t x =
    match t with
    | Empty -> false
    | Interval (l, h) -> Endpoint.compare x l >= 0 && Endpoint.compare x h <= 0

  (** [intersect t1 t2] returns the intersection of the two input intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y <= 0 then x else y in
    let max x y = if Endpoint.compare x y >= 0 then x else y in
    match (t1, t2) with
    | Empty, _ | _, Empty -> Empty
    | Interval (l1, h1), Interval (l2, h2) -> create (max l1 l2) (min h1 h2)
end

module Int_interval_v2 = Make_interval_v2 (Int)

(* Now, this works *)
let _ = Int_interval_v2.create 3 4

(* Option02: Destructive Substitution. This is better solution *)
module Make_interval_v3 (Endpoint : Comparable) : Interval_intf with type endpoint := Endpoint.t =
struct
  type t = Interval of Endpoint.t * Endpoint.t | Empty

  (** [create low high] creates a new interval from [low] to [high]. If [low > high], then the
      interval is empty *)
  let create low high = if Endpoint.compare low high > 0 then Empty else Interval (low, high)

  (** Returns true iff the interval is empty *)
  let is_empty = function Empty -> true | Interval _ -> false

  (** [contains t x] returns true iff [x] is contained in the interval [t] *)
  let contains t x =
    match t with
    | Empty -> false
    | Interval (l, h) -> Endpoint.compare x l >= 0 && Endpoint.compare x h <= 0

  (** [intersect t1 t2] returns the intersection of the two input intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y <= 0 then x else y in
    let max x y = if Endpoint.compare x y >= 0 then x else y in
    match (t1, t2) with
    | Empty, _ | _, Empty -> Empty
    | Interval (l1, h1), Interval (l2, h2) -> create (max l1 l2) (min h1 h2)
end

module Int_interval_v3 = Make_interval_v3 (Int)

(* Now, this works *)
let _ = Int_interval_v3.is_empty (Int_interval_v3.create 3 4)
(* let _ = Int_interval_v3.is_empty (Int_interval.Interval (4, 3)) 
Now, this will not compile
*)
